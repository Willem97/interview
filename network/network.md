
<!-- TOC -->

- [1. 网络模型](#1-网络模型)
    - [1.1. OSI模型](#11-osi模型)
    - [1.2. TCP/IP分层模型](#12-tcpip分层模型)
- [2. UDP协议](#2-udp协议)
- [3. TCP协议](#3-tcp协议)
    - [3.1. TCP短连接和长链接](#31-tcp短连接和长链接)
        - [3.1.1. 短连接](#311-短连接)
        - [3.1.2. 长链接](#312-长链接)
    - [3.2. 三次握手](#32-三次握手)
        - [3.2.1. 示意图](#321-示意图)
        - [3.2.2. 通俗版：](#322-通俗版)
    - [3.3. 四次挥手](#33-四次挥手)
    - [3.4. TCP流量控制](#34-tcp流量控制)
    - [3.5. TCP拥塞控制](#35-tcp拥塞控制)
        - [3.5.1. 慢启动](#351-慢启动)
        - [3.5.2. 拥塞避免](#352-拥塞避免)
        - [3.5.3. 拥塞发生](#353-拥塞发生)
            - [3.5.3.1. 超时重传时的拥塞发生](#3531-超时重传时的拥塞发生)
            - [3.5.3.2. 快速重传时的拥塞发生](#3532-快速重传时的拥塞发生)
        - [3.5.4. 快速恢复](#354-快速恢复)
- [4. http与https](#4-http与https)
- [5. 一次HTTP请求的完整过程](#5-一次http请求的完整过程)

<!-- /TOC -->

# 1. 网络模型

## 1.1. OSI模型

- 应用层
- 表示层
- 会话层
- 传输层
- 网络层
- 数据链路层
- 物理层

## 1.2. TCP/IP分层模型

- 应用层
- 传输层
- 网络层
- 网络接口层

# 2. UDP协议

`UDP, 用户数据报协议(User Datagram Protocol)`
是无连接的，尽最大可能交付，没用拥塞控制，面向报文（对于应用程序传下来的报文不合并也不拆分，只是添加UDP首部），支持一对一、一对多、多对一和多对多的交互通信。
# 3. TCP协议

`TCP,  传输控制协议(Transmission Control Protocol)`
是 **`面向连接`** 的，提供 **`可靠`** 交付，有流量控制，拥塞控制，提供全双工通信，面向 **`字节流`**（把应用层传下来的报文看成字节流，把字节流组织成大小不等的数据块），每一条TCP连接只能是点对点的（一对一）。

## 3.1. TCP短连接和长链接

### 3.1.1. 短连接

Client向server发送消息，Server回应Client，然后一次读写就完成，双方任何一个都可以发起close操作，不过一般都是client端操作。短连接一般只会在Client/Server间传递一次读写操作。

优点：管理简单，建立存在的连接都是有用的连接，不需要额外的控制手段。

### 3.1.2. 长链接

Client与Server完成一次读写之后，它们之间的连接并不会主动关闭，后续的读写操作会继续使用此连接。

优点：
## 3.2. 三次握手

`三次握手（Three-way handshake）` 其实就是只见里。进行三次握手的主要作用就是**为了确认双方的双方的接收能力和发送能力是否正常、指定自己的初始化序列号为后面的可靠性传输做准备**。

### 3.2.1. 示意图

### 3.2.2. 通俗版：
## 3.3. 四次挥手


## 3.4. TCP流量控制

流量控制是为了控制发送方发送速率，以保证接收方来得及接收。**避免发送方的数据填满了接收方的缓存**。

接收方发送的确认报文中的窗口字段可以用来控制发送窗口大小（`ACK`报文），从而影响发送方的发送速率，将窗口字段设置为0（即**窗口关闭**），则发送方不能发送数据。

TCP为每个链接设有一个持续定时器，只要TCP连接一方接收到对方的零窗口通知，就启动持续定时器，如果定时器超时，发送窗口探测报文。
**实际上，为了避免此问题产生，发送端主机会时不时地发送一个叫做窗口探测（`Window probe`）的数据段，**，此数据段仅包含一个字节来获取最新的窗口大小信息。

## 3.5. TCP拥塞控制

在网络上出现拥堵时，如果继续发送大量数据包，可能会导致数据包时延、丢失等，这时TCP就会重传数据，但是一重传就会导致网络的负担更重，
于是会导致更大的延迟以及更多的丢包，因此就有了拥塞控制，**目的是避免发送方的数据填满整个网络**。

为了在发送方调节发送数据的量，定义了一个叫做 **拥塞窗口（`cwnd`）** 的概念，会根据网络的拥塞程度动态变化的。没有堵塞，cwnd增大，出现拥塞，cwnd减小。

拥塞空乃至的四个算法：
### 3.5.1. 慢启动

当发送发每收到一个 `ACK`，拥塞窗口 `cwnd` 的大小就会加1。慢启动算法发包的个数是指数性增长。

但是有一个 **慢启动门限 `ssthresh (slow start threshold)`**，一般来说其大小是 `65536 字节`。
- 当 `cwnd < ssthresh` 时，使用慢启动算法
- 当 `cwnd >= ssthresh` 时，就会使用拥塞避免算法

### 3.5.2. 拥塞避免
进入拥塞避免算法后，它的规则是：每当收到一个 `ACK` 时，`cwnd` 增加 `1/cwnd`。

拥塞避免算法是原本慢启动算法的指数增长变成了线性增长，速度变缓。一直这样增长，网络就会慢慢进入拥塞的状况，出现丢包，这时就会对丢包进行重传。

当触发了**重传机制**，也就进入了 **`拥塞发生算法`**。

### 3.5.3. 拥塞发生

当网络出现拥塞，也就是发送数据包重传，重传机制主要有两种：
- 超时重传
- 快速重传

#### 3.5.3.1. 超时重传时的拥塞发生

此时, `ssthresh` 设为 `cwnd/2`， `cwnd` 重置为 `1`。

这时会重新开始慢启动，慢启动会突然减少数据流的，一旦超时重传，反应强烈，造成网络卡顿。

#### 3.5.3.2. 快速重传时的拥塞发生

TCP任务认为这种情况不严重，因为大部分没有丢失，则具体变化为
- `cwnd = cwnd/2`，设为原来的一半；
- `ssthresh = cwnd` ；
- 进入快速恢复算法
### 3.5.4. 快速恢复

进入快速恢复算法如下：

- 拥塞窗口 `cwnd = ssthresh + 3` （ `3` 的意思是确认有 `3` 个数据包被收到了）；
- 重传丢失的数据包；
- 如果再收到重复的 `ACK`，那么 `cwnd` 增加 `1`；
- 如果收到新数据的 `ACK` 后，把 `cwnd` 设置为第一步中的 `ssthresh` 的值，原因是该 `ACK` 确认了新的数据，说明从 `duplicated ACK` 时的数据都已收到，该恢复过程已经结束，可以回到恢复之前的状态了，也即再次进入拥塞避免状态；

![](media/tcp_congestion.jpeg "算法示意图")


# 4. http与https


# 5. 一次HTTP请求的完整过程


1. 根据域名和DNS解析到服务器的IP地址（DNS+CDN）
2. 通过ARP协议获取IP地址对应的物理机器的MAC地址
3. 浏览器对服务器发起·TCP·3次握手
4. 建立TCP连接后发起HTTP请求报文
5. 服务器响应HTTP请求，将响应报文返回给浏览器
6. 短连接情况下，请求结束则通过TCP四次挥手关闭连接，长连接在没有访问服务器的若干时间后，进行连接的关闭
7. 浏览器得到响应信息中的HTML代码，并请求HTML代码中的资源（js、css、图片等）
8. 浏览器对页面进行渲染呈现给用户